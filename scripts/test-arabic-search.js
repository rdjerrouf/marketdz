#!/usr/bin/env node

/**
 * Arabic RTL Search Testing Script for MarketDZ
 * Tests Unicode normalization, stemming, and search functionality
 */

const { createClient } = require('@supabase/supabase-js');

// Test data with various Arabic text forms
const ARABIC_TEST_LISTINGS = [
  {
    title: 'ÿ≥Ÿäÿßÿ±ÿ© ŸÖÿ±ÿ≥ŸäÿØÿ≥ ŸÑŸÑÿ®Ÿäÿπ',
    description: 'ÿ≥Ÿäÿßÿ±ÿ© ŸÖÿ±ÿ≥ŸäÿØÿ≥ ÿ®ÿ≠ÿßŸÑÿ© ŸÖŸÖÿ™ÿßÿ≤ÿ©ÿå ŸÖŸàÿØŸäŸÑ 2020ÿå ŸÑŸàŸÜ ÿ£ÿ≥ŸàÿØÿå ÿπÿØÿØ ÿßŸÑŸÉŸäŸÑŸàŸÖÿ™ÿ±ÿßÿ™ ŸÇŸÑŸäŸÑ',
    category: 'for_sale',
    location_wilaya: 'ÿßŸÑÿ¨ÿ≤ÿßÿ¶ÿ±',
    price: 2500000
  },
  {
    title: 'ÿ¥ŸÇÿ© ŸÑŸÑÿ•Ÿäÿ¨ÿßÿ± ŸÅŸä ÿßŸÑÿ¨ÿ≤ÿßÿ¶ÿ± ÿßŸÑÿπÿßÿµŸÖÿ©',
    description: 'ÿ¥ŸÇÿ© ÿ¨ŸÖŸäŸÑÿ© ŸàŸÖŸÅÿ±Ÿàÿ¥ÿ© ŸÅŸä ÿ≠Ÿä ÿ±ÿßŸÇŸäÿå 3 ÿ∫ÿ±ŸÅ ŸÜŸàŸÖÿå ŸÖÿ∑ÿ®ÿÆ ÿ≠ÿØŸäÿ´ÿå ÿ•ÿ∑ŸÑÿßŸÑÿ© ÿ±ÿßÿ¶ÿπÿ© ÿπŸÑŸâ ÿßŸÑÿ®ÿ≠ÿ±',
    category: 'service', 
    location_wilaya: 'ÿßŸÑÿ¨ÿ≤ÿßÿ¶ÿ±',
    price: 50000
  },
  {
    title: 'Ÿáÿßÿ™ŸÅ ÿ£ŸäŸÅŸàŸÜ ÿ¨ÿØŸäÿØ',
    description: 'ÿ£ŸäŸÅŸàŸÜ 14 ÿ®ÿ±Ÿà ŸÖÿßŸÉÿ≥ÿå 256 ÿ¨Ÿäÿ¨ÿßÿ®ÿßŸäÿ™ÿå ŸÑŸàŸÜ ÿ∞Ÿáÿ®Ÿäÿå ÿ¨ÿØŸäÿØ ÿ®ÿßŸÑŸÉÿ±ÿ™ŸàŸÜÿ© ÿßŸÑÿ£ÿµŸÑŸäÿ© ŸÖÿπ ŸÉÿßŸÖŸÑ ÿßŸÑŸÖŸÑÿ≠ŸÇÿßÿ™',
    category: 'for_sale',
    location_wilaya: 'ŸàŸáÿ±ÿßŸÜ',
    price: 180000
  },
  {
    title: 'ÿÆÿØŸÖÿßÿ™ ÿßŸÑÿ™ÿµŸÖŸäŸÖ ÿßŸÑÿ¨ÿ±ÿßŸÅŸäŸÉŸä', 
    description: 'ÿ£ŸÇÿØŸÖ ÿÆÿØŸÖÿßÿ™ ÿ™ÿµŸÖŸäŸÖ ÿßŸÑÿ¥ÿπÿßÿ±ÿßÿ™ ŸàÿßŸÑŸáŸàŸäÿ© ÿßŸÑÿ®ÿµÿ±Ÿäÿ© ŸàÿßŸÑÿ™ÿµŸÖŸäŸÖ ÿßŸÑÿ•ÿπŸÑÿßŸÜŸä ÿ®ÿ¨ŸàÿØÿ© ÿπÿßŸÑŸäÿ© Ÿàÿ£ÿ≥ÿπÿßÿ± ŸÖŸÜÿßŸÅÿ≥ÿ©',
    category: 'service',
    location_wilaya: 'ŸÇÿ≥ŸÜÿ∑ŸäŸÜÿ©',
    price: 5000
  },
  {
    title: 'ŸÉÿ™ÿ® ÿ¨ÿßŸÖÿπŸäÿ© ŸÑŸÑÿ®Ÿäÿπ',
    description: 'ŸÖÿ¨ŸÖŸàÿπÿ© ŸÉÿ™ÿ® ŸÅŸä ÿßŸÑŸáŸÜÿØÿ≥ÿ© ÿßŸÑŸÖÿØŸÜŸäÿ© ŸàÿßŸÑÿ±Ÿäÿßÿ∂Ÿäÿßÿ™ÿå ÿ≠ÿßŸÑÿ© ÿ¨ŸäÿØÿ©ÿå ŸÖŸÜÿßÿ≥ÿ®ÿ© ŸÑÿ∑ŸÑÿßÿ® ÿßŸÑÿ¨ÿßŸÖÿπÿ©',
    category: 'for_sale', 
    location_wilaya: 'ÿ≥ÿ∑ŸäŸÅ',
    price: 8000
  }
];

// Test queries with various Arabic forms and diacritics
const SEARCH_TEST_CASES = [
  {
    query: 'ÿ≥Ÿäÿßÿ±ÿ©',
    description: 'Basic Arabic word search',
    expectedResults: ['ÿ≥Ÿäÿßÿ±ÿ© ŸÖÿ±ÿ≥ŸäÿØÿ≥ ŸÑŸÑÿ®Ÿäÿπ']
  },
  {
    query: 'ÿ≥Ÿäÿßÿ±Ÿá', // Different Teh Marbuta form
    description: 'Alternative spelling with Teh Marbuta',
    expectedResults: ['ÿ≥Ÿäÿßÿ±ÿ© ŸÖÿ±ÿ≥ŸäÿØÿ≥ ŸÑŸÑÿ®Ÿäÿπ']
  },
  {
    query: 'ŸÖÿ±ÿ≥ŸäÿØÿ≥',
    description: 'Brand name search',
    expectedResults: ['ÿ≥Ÿäÿßÿ±ÿ© ŸÖÿ±ÿ≥ŸäÿØÿ≥ ŸÑŸÑÿ®Ÿäÿπ']
  },
  {
    query: 'ÿ¥ŸÇŸá', // Alternative Teh Marbuta
    description: 'Apartment search with different spelling',
    expectedResults: ['ÿ¥ŸÇÿ© ŸÑŸÑÿ•Ÿäÿ¨ÿßÿ± ŸÅŸä ÿßŸÑÿ¨ÿ≤ÿßÿ¶ÿ± ÿßŸÑÿπÿßÿµŸÖÿ©']
  },
  {
    query: 'ÿßŸäŸÅŸàŸÜ', // Without Hamza
    description: 'iPhone search without Hamza',
    expectedResults: ['Ÿáÿßÿ™ŸÅ ÿ£ŸäŸÅŸàŸÜ ÿ¨ÿØŸäÿØ']
  },
  {
    query: 'ÿ£ŸäŸÅŸàŸÜ', // With Hamza
    description: 'iPhone search with Hamza', 
    expectedResults: ['Ÿáÿßÿ™ŸÅ ÿ£ŸäŸÅŸàŸÜ ÿ¨ÿØŸäÿØ']
  },
  {
    query: 'ÿ™ÿµŸÖŸäŸÖ',
    description: 'Design services search',
    expectedResults: ['ÿÆÿØŸÖÿßÿ™ ÿßŸÑÿ™ÿµŸÖŸäŸÖ ÿßŸÑÿ¨ÿ±ÿßŸÅŸäŸÉŸä']
  },
  {
    query: 'ŸÉÿ™ÿßÿ®', // Singular form
    description: 'Book search (singular)',
    expectedResults: ['ŸÉÿ™ÿ® ÿ¨ÿßŸÖÿπŸäÿ© ŸÑŸÑÿ®Ÿäÿπ']
  },
  {
    query: 'ÿ¨ÿØŸäÿØ',
    description: 'Search for new items',
    expectedResults: ['Ÿáÿßÿ™ŸÅ ÿ£ŸäŸÅŸàŸÜ ÿ¨ÿØŸäÿØ', 'ŸÉÿ™ÿ® ÿ¨ÿßŸÖÿπŸäÿ© ŸÑŸÑÿ®Ÿäÿπ']
  },
  {
    query: 'ÿßŸÑÿ¨ÿ≤ÿßÿ¶ÿ±',
    description: 'Location-based search',
    expectedResults: ['ÿ≥Ÿäÿßÿ±ÿ© ŸÖÿ±ÿ≥ŸäÿØÿ≥ ŸÑŸÑÿ®Ÿäÿπ', 'ÿ¥ŸÇÿ© ŸÑŸÑÿ•Ÿäÿ¨ÿßÿ± ŸÅŸä ÿßŸÑÿ¨ÿ≤ÿßÿ¶ÿ± ÿßŸÑÿπÿßÿµŸÖÿ©']
  }
];

class ArabicSearchTester {
  constructor() {
    this.supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL || 'http://127.0.0.1:54321',
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZS1kZW1vIiwicm9sZSI6ImFub24iLCJleHAiOjE5ODM4MTI5OTZ9.CRXP1A7WOeoJeXxjNni43kdQwgnWNReilDMblYTn_I0'
    );
    this.testResults = [];
  }

  async setupTestData() {
    console.log('üîÑ Setting up Arabic test data...');
    
    // Create test user profile
    const testUserId = '00000000-0000-0000-0000-000000000001';
    
    // Insert test user (if not exists)
    await this.supabase.from('profiles').upsert({
      id: testUserId,
      full_name: 'Arabic Test User',
      wilaya: 'ÿßŸÑÿ¨ÿ≤ÿßÿ¶ÿ±',
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    });

    // Clean up existing test data
    await this.supabase
      .from('listings')
      .delete()
      .ilike('title', '%test%');

    // Insert test listings
    for (const listing of ARABIC_TEST_LISTINGS) {
      const { error } = await this.supabase
        .from('listings')
        .insert({
          ...listing,
          seller_id: testUserId,
          status: 'active',
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        });

      if (error) {
        console.error('Failed to insert test listing:', error);
      }
    }

    console.log(`‚úÖ Inserted ${ARABIC_TEST_LISTINGS.length} test listings`);
  }

  async testNormalization() {
    console.log('\nüìù Testing Arabic text normalization...');
    
    const testCases = [
      { input: 'ÿ£ŸäŸÅŸàŸÜ', expected: 'ÿßŸäŸÅŸàŸÜ', description: 'Alif with Hamza normalization' },
      { input: 'ÿ≥Ÿäÿßÿ±Ÿá', expected: 'ÿ≥Ÿäÿßÿ±Ÿá', description: 'Teh Marbuta handling' },
      { input: 'ÿßŸÑÿ•ÿ≥ŸÑÿßŸÖ', expected: 'ÿßŸÑÿßÿ≥ŸÑÿßŸÖ', description: 'Alif with Hamza under normalization' },
      { input: 'ŸÖŸèÿ≠ŸéŸÖŸéŸëÿØ', expected: 'ŸÖÿ≠ŸÖÿØ', description: 'Diacritics removal' }
    ];

    for (const testCase of testCases) {
      try {
        const { data, error } = await this.supabase.rpc('normalize_arabic_text', {
          input_text: testCase.input
        });

        if (error) {
          console.error(`‚ùå Normalization failed for "${testCase.input}":`, error);
          continue;
        }

        const success = data === testCase.expected || data.includes(testCase.expected.replace(/Ÿá$/, 'ÿ©'));
        console.log(`${success ? '‚úÖ' : '‚ùå'} ${testCase.description}`);
        console.log(`   Input: "${testCase.input}" ‚Üí Output: "${data}"`);
        
        this.testResults.push({
          test: 'normalization',
          case: testCase.description,
          success,
          input: testCase.input,
          output: data,
          expected: testCase.expected
        });
      } catch (error) {
        console.error(`‚ùå Error testing normalization for "${testCase.input}":`, error);
      }
    }
  }

  async testSearchFunctionality() {
    console.log('\nüîç Testing Arabic search functionality...');

    for (const testCase of SEARCH_TEST_CASES) {
      console.log(`\nTesting: ${testCase.description}`);
      console.log(`Query: "${testCase.query}"`);

      try {
        // Test with Arabic search mode
        const { data: arabicResults, error: arabicError } = await this.supabase
          .rpc('search_listings_arabic', {
            search_term: testCase.query,
            search_mode: 'arabic',
            limit_count: 10
          });

        if (arabicError) {
          console.error(`‚ùå Arabic search failed:`, arabicError);
          continue;
        }

        // Test with mixed search mode  
        const { data: mixedResults, error: mixedError } = await this.supabase
          .rpc('search_listings_arabic', {
            search_term: testCase.query,
            search_mode: 'mixed',
            limit_count: 10
          });

        if (mixedError) {
          console.error(`‚ùå Mixed search failed:`, mixedError);
          continue;
        }

        // Analyze results
        const arabicTitles = arabicResults?.map(r => r.title) || [];
        const mixedTitles = mixedResults?.map(r => r.title) || [];
        
        const arabicMatch = testCase.expectedResults.some(expected =>
          arabicTitles.some(title => title.includes(expected.split(' ')[0]))
        );
        
        const mixedMatch = testCase.expectedResults.some(expected =>
          mixedTitles.some(title => title.includes(expected.split(' ')[0]))
        );

        console.log(`   Arabic mode: ${arabicResults?.length || 0} results ${arabicMatch ? '‚úÖ' : '‚ùå'}`);
        console.log(`   Mixed mode: ${mixedResults?.length || 0} results ${mixedMatch ? '‚úÖ' : '‚ùå'}`);
        
        if (arabicResults?.length > 0) {
          console.log(`   Top result: "${arabicResults[0].title}" (rank: ${arabicResults[0].search_rank})`);
        }

        this.testResults.push({
          test: 'search',
          case: testCase.description,
          query: testCase.query,
          arabicSuccess: arabicMatch,
          mixedSuccess: mixedMatch,
          arabicResults: arabicResults?.length || 0,
          mixedResults: mixedResults?.length || 0
        });

      } catch (error) {
        console.error(`‚ùå Search test failed for "${testCase.query}":`, error);
      }
    }
  }

  async testAutocompleteSuggestions() {
    console.log('\nüí° Testing Arabic autocomplete suggestions...');

    const partialQueries = ['ÿ≥Ÿä', 'Ÿáÿßÿ™', 'ÿ™ÿµ', 'ŸÉÿ™'];

    for (const partial of partialQueries) {
      try {
        const { data, error } = await this.supabase
          .rpc('search_arabic_suggestions', {
            partial_term: partial,
            limit_count: 5
          });

        if (error) {
          console.error(`‚ùå Suggestions failed for "${partial}":`, error);
          continue;
        }

        console.log(`\nSuggestions for "${partial}":`);
        if (data && data.length > 0) {
          data.forEach(suggestion => {
            console.log(`   ‚Ä¢ ${suggestion.suggestion} (${suggestion.frequency} matches, category: ${suggestion.category})`);
          });
          console.log(`   ‚úÖ ${data.length} suggestions found`);
        } else {
          console.log(`   ‚ùå No suggestions found`);
        }

        this.testResults.push({
          test: 'autocomplete',
          query: partial,
          suggestions: data?.length || 0,
          success: data && data.length > 0
        });

      } catch (error) {
        console.error(`‚ùå Autocomplete test failed for "${partial}":`, error);
      }
    }
  }

  async testPerformance() {
    console.log('\n‚ö° Testing search performance...');

    const queries = ['ÿ≥Ÿäÿßÿ±ÿ©', 'ÿ¥ŸÇÿ©', 'Ÿáÿßÿ™ŸÅ', 'ÿ™ÿµŸÖŸäŸÖ'];

    for (const query of queries) {
      const startTime = Date.now();
      
      try {
        const { data, error } = await this.supabase
          .rpc('search_listings_arabic', {
            search_term: query,
            search_mode: 'mixed',
            limit_count: 20
          });

        const duration = Date.now() - startTime;

        if (error) {
          console.error(`‚ùå Performance test failed for "${query}":`, error);
          continue;
        }

        const success = duration < 500; // Should complete in under 500ms
        console.log(`   "${query}": ${duration}ms, ${data?.length || 0} results ${success ? '‚úÖ' : '‚ùå'}`);

        this.testResults.push({
          test: 'performance',
          query,
          duration,
          results: data?.length || 0,
          success
        });

      } catch (error) {
        console.error(`‚ùå Performance test error for "${query}":`, error);
      }
    }
  }

  async generateReport() {
    console.log('\nüìä ARABIC SEARCH TEST REPORT');
    console.log('=' .repeat(50));

    const testTypes = ['normalization', 'search', 'autocomplete', 'performance'];
    
    for (const testType of testTypes) {
      const tests = this.testResults.filter(r => r.test === testType);
      if (tests.length === 0) continue;

      console.log(`\n${testType.toUpperCase()} TESTS:`);
      console.log('-'.repeat(30));

      let successCount = 0;
      tests.forEach(test => {
        const success = test.success || test.arabicSuccess || test.mixedSuccess;
        if (success) successCount++;

        if (testType === 'search') {
          console.log(`${success ? '‚úÖ' : '‚ùå'} ${test.case} - "${test.query}"`);
          console.log(`   Arabic: ${test.arabicResults} results, Mixed: ${test.mixedResults} results`);
        } else if (testType === 'performance') {
          console.log(`${success ? '‚úÖ' : '‚ùå'} "${test.query}" - ${test.duration}ms (${test.results} results)`);
        } else {
          console.log(`${success ? '‚úÖ' : '‚ùå'} ${test.case || test.query}`);
        }
      });

      console.log(`\nSuccess Rate: ${successCount}/${tests.length} (${Math.round(successCount/tests.length*100)}%)`);
    }

    // Overall summary
    const totalTests = this.testResults.length;
    const totalSuccess = this.testResults.filter(r => 
      r.success || r.arabicSuccess || r.mixedSuccess
    ).length;

    console.log('\nüéØ OVERALL RESULTS:');
    console.log('-'.repeat(30)); 
    console.log(`Total Tests: ${totalTests}`);
    console.log(`Passed: ${totalSuccess}`);
    console.log(`Failed: ${totalTests - totalSuccess}`);
    console.log(`Success Rate: ${Math.round(totalSuccess/totalTests*100)}%`);

    // Recommendations
    console.log('\nüí° RECOMMENDATIONS:');
    console.log('-'.repeat(30));
    
    const failedNormalization = this.testResults.filter(r => r.test === 'normalization' && !r.success);
    if (failedNormalization.length > 0) {
      console.log('‚Ä¢ Improve Unicode normalization for complex diacritics');
    }

    const failedSearches = this.testResults.filter(r => r.test === 'search' && !r.arabicSuccess && !r.mixedSuccess);
    if (failedSearches.length > 0) {
      console.log('‚Ä¢ Enhance Arabic stemming dictionary for better word matching');
    }

    const slowQueries = this.testResults.filter(r => r.test === 'performance' && r.duration > 300);
    if (slowQueries.length > 0) {
      console.log('‚Ä¢ Optimize indexes for queries taking longer than 300ms');
    }

    console.log('\nüèÅ Arabic RTL search testing completed!');
  }

  async runAllTests() {
    try {
      await this.setupTestData();
      await this.testNormalization();
      await this.testSearchFunctionality(); 
      await this.testAutocompleteSuggestions();
      await this.testPerformance();
      await this.generateReport();
    } catch (error) {
      console.error('Test suite failed:', error);
    }
  }
}

// Run tests if called directly
if (require.main === module) {
  const tester = new ArabicSearchTester();
  tester.runAllTests();
}

module.exports = { ArabicSearchTester, ARABIC_TEST_LISTINGS, SEARCH_TEST_CASES };